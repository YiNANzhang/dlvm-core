module ffnn

type ffnn_params = ([4x4 x f32], [8x8 x f32], [8x8 x f32], [4x1 x f32], [8x1 x f32], [8x1 x f32])

@differentiable
func @inference(%i1 : [4x1 x f32], %i2 : [4x1 x f32], %params : ffnn_params) -> [1x8 x f32] {
entry(%i1 : [4x1 x f32], %i2 : [4x1 x f32], %params : ffnn_params):
    %v0 = extract %params : ffnn_params at 0
    %v1 = extract %params : ffnn_params at 1
    %v2 = extract %params : ffnn_params at 2
    %v3 = extract %params : ffnn_params at 3
    %v4 = extract %params : ffnn_params at 4
    %v5 = extract %params : ffnn_params at 5
    %v6 = matrixMultiply %v0 : [4x4 x f32], %i1 : [4x1 x f32]
    %v7 = add %v6 : [4x1 x f32], %v3 : [4x1 x f32]
    %h1 = sigmoid %v7 : [4x1 x f32]
    %v8 = concatenate %h1 : [4x1 x f32], %i2 : [4x1 x f32] along 0
    %v9 = subtract 1.0 : f32, %v8 : [8x1 x f32]
    %v10 = matrixMultiply %v1 : [8x8 x f32], %v9 : [8x1 x f32]
    %v11 = add %v10 : [8x1 x f32], %v4 : [8x1 x f32]
    %h2 = max 0.0 : f32, %v11 : [8x1 x f32]
    %v12 = matrixMultiply %v2 : [8x8 x f32], %h2 : [8x1 x f32]
    %v13 = add %v12 : [8x1 x f32], %v5 : [8x1 x f32]
    %v14 = softmax %v13 : [8x1 x f32]
    %o = transpose %v14 : [8x1 x f32]
    return %o : [1x8 x f32]
}

@differentiating(@inference)
@differentiable
func @inference_gradient(%i1 : [4x1 x f32], %i2 : [4x1 x f32], %params : ffnn_params) -> ([4x1 x f32], [4x1 x f32], ffnn_params) {
entry(%i1 : [4x1 x f32], %i2 : [4x1 x f32], %params : ffnn_params):
    %v0 = tuple %i1 : [4x1 x f32], %i2 : [4x1 x f32], %params : ffnn_params
    return %v0 : ([4x1 x f32], [4x1 x f32], ffnn_params)
}

