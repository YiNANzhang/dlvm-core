module ffnn

type ffnn_params = ([4x4 x f32], [8x8 x f32], [8x8 x f32], [4x1 x f32], [8x1 x f32], [8x1 x f32])

@differentiable
func @inference(%i1 : [4x1 x f32], %i2 : [4x1 x f32], %params : ffnn_params) -> [1x8 x f32] {
entry(%i1 : [4x1 x f32], %i2 : [4x1 x f32], %params : ffnn_params):
    %v0 = element 0 of %params : ffnn_params
    %v1 = element 1 of %params : ffnn_params
    %v2 = element 2 of %params : ffnn_params
    %v3 = element 3 of %params : ffnn_params
    %v4 = element 4 of %params : ffnn_params
    %v5 = element 5 of %params : ffnn_params
    %v6 = matrixMultiply %v0 : [4x4 x f32], %i1 : [4x1 x f32]
    %v7 = add %v6 : [4x1 x f32], %v3 : [4x1 x f32]
    %h1 = sigmoid %v7 : [4x1 x f32]
    %v8 = concatenate %h1 : [4x1 x f32], %i2 : [4x1 x f32] along 0
    %v9 = subtract 1.0 : f32, %v8 : [8x1 x f32]
    %v10 = matrixMultiply %v1 : [8x8 x f32], %v9 : [8x1 x f32]
    %v11 = add %v10 : [8x1 x f32], %v4 : [8x1 x f32]
    %h2 = max 0.0 : f32, %v11 : [8x1 x f32]
    %v12 = matrixMultiply %v2 : [8x8 x f32], %h2 : [8x1 x f32]
    %v13 = add %v12 : [8x1 x f32], %v5 : [8x1 x f32]
    %v14 = softmax %v13 : [8x1 x f32]
    %o = transpose %v14 : [8x1 x f32]
    return %o : [1x8 x f32]
}

@differentiable
func @âˆ‡inference(%i1 : [4x1 x f32], %i2 : [4x1 x f32], %params : ffnn_params) -> ([4x1 x f32], [4x1 x f32], ffnn_params) {
entry(%i1 : [4x1 x f32], %i2 : [4x1 x f32], %params : ffnn_params):
}

